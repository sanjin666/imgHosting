---
title: "äºŒå‰æ ‘ç¯‡"
type: "LeetCodeé¢˜è§£""
---



## LeetCodeäºŒå‰æ ‘ç¯‡é¢˜è§£,çœ‹è¿™ä¸€ç¯‡å°±å¤Ÿäº†

[TOC]



### åŸºç¡€çŸ¥è¯†

[äºŒå‰æ ‘çš„åŸºç¡€çŸ¥è¯†å‚è€ƒ](https://blog.csdn.net/xiaoquantouer/article/details/65631708?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161535239116780262513035%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161535239116780262513035&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-65631708.first_rank_v2_pc_rank_v29&utm_term=äºŒå‰æ ‘)

javaä¸­æä¾›[DequeåŒç«¯é˜Ÿåˆ—](https://blog.csdn.net/u013967628/article/details/85210036?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.baidujs&dist_request_id=109de421-e817-4ab1-90e4-e032c695d036&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.baidujs)å®ç°é˜Ÿåˆ—ä¸æ ˆçš„å„ç§éœ€æ±‚, é¢˜ç›®ä¸­ç»å¸¸ä¼šç”¨åˆ°å¦‚ä¸‹

+ offerlast(node)æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
+ offerFist(node)æ·»åŠ å…ƒç´ åˆ°é˜Ÿå¤´
+ new LinkedList<>(deque), åˆ©ç”¨åŒç«¯é˜Ÿåˆ—æ–°å»ºåˆ—è¡¨
+ ä»¥ä¸Šä¸‰æ­¥å¯ç”¨ List åˆ—è¡¨çš„ add(node) å°¾æ’ ,  add(0,node)å¤´æ’ç›´æ¥å®ç°

-----

### æ ‘çš„ä¸‰ç§éå†

+ äºŒå‰æœç´¢æ ‘çš„éå†å…±æœ‰å››ç§, å³å‰åºéå†ã€ä¸­åºéå†ã€ååºéå†ã€ä»¥åŠå±‚åºéå†ã€è¿™å››ç§éå†æ–¹å¼æ˜¯ BST çš„é‡ä¸­ä¹‹é‡, å¤§éƒ¨åˆ†æ ‘çš„é¢˜ç›®éƒ½å¯ä»¥åœ¨è¿™å››ç§éå†çš„åŸºç¡€ä¸Šä¿®æ”¹å¾—ä»¥è§£ç­”. æ‰€ä»¥æˆ‘ä»¬å¿…é¡»**ç‰¢è®°**å®ƒä»¬çš„å†™æ³•.

+ é¦–å…ˆè®©æˆ‘ä»¬é€šè¿‡ä¸‰é“é¢˜æ¥äº†è§£ BST çš„å‰åº, ä¸­åº, ååºéå†, åŒæ—¶,æ¯ç§éå†åˆå¯ä»¥ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹å¼å®ç°, æœ€åæˆ‘ä»¬è¿˜è¡¥å……ä¸€ä¸ªè¿­ä»£çš„ç»Ÿä¸€å†™æ³•.

  [94ã€äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  [144ã€äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  [145ã€äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```java
//æ ‘èŠ‚ç‚¹ç±»å®šä¹‰
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int x) {
        val = x;
    }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```



#### é€’å½’å®ç°

```java
List<Integer> list = new ArrayList<>();

//å‰åºéå†
public void preorder(TreeNode root){
    if(root != null){
        list.add(root.val);
        preorder(root.left);
        preorder(root.right);
    }
}

//ä¸­åºéå†
public void inorder(TreeNode root){
    if(root != null){
        inorder(root.left);
        list.add(root.val);
        inorder(root.right);
    }
}

//ååºéå†
public void backorder(TreeNode root){
    if(root != null){
        backorder(root.left);
        backorder(root.right);
        list.add(root.val);
    }
}
```



#### æ ˆè¿­ä»£

```java
//å…ˆåºéå†
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stk = new LinkedList<TreeNode>();
    while(root != null || !stk.isEmpty()){
        while(root != null){
            res.add(root.val);//å…ˆåºå’Œä¸­åºçš„å·®åˆ«å°±æ˜¯è¿™æ¡è¯­å¥çš„æ’å…¥ä½ç½®
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        root = root.right;
    }
    return res;
}

//ä¸­åºéå†
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stk = new LinkedList<TreeNode>();
    while(root != null || !stk.isEmpty()){
        while(root != null){
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        res.add(root.val);
        root = root.right;
    }
    return res;
}

//ååºéå†
//ä¸ä¸­åºå’Œå‰åºçš„ç»“æ„å·®åˆ«å¤§,ä¸ä¾¿è®°å¿†
```



#### ç»Ÿä¸€ç»“æ„: å‚è€ƒ[é¢œè‰²æ ‡è®°æ³•](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/)

+ å®ç°äº†å‰ä¸­ååºéå†çš„ç»Ÿä¸€ç»“æ„å†™æ³•,åªéœ€æ”¹å˜èŠ‚ç‚¹çš„è¿›æ ˆé¡ºåº

```java
public List<Integer> inorderTravelsal(TreeNode root){

    HashMap<TreeNode, Integer> map = new HashMap<>();
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    
    if(root == null)  //åˆå§‹æ£€æŸ¥
    	return res;
    
    //æ ¹èŠ‚ç‚¹è¿›æ ˆ
    stack.push(root);
    map.put(root,1); //1 è¡¨ç¤ºç¬¬ä¸€æ¬¡è®¿é—®, 2 è¡¨ç¤ºç¬¬äºŒæ¬¡è®¿é—®
  
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        
        if(1 == map.get(node)){
          
            //ä¸­åºéå†,å› ä¸ºæ ˆçš„ç‰¹ç‚¹,å…ˆè¿›åå‡º,å³-ä¸­-å·¦è¿›æ ˆ, å‡ºæ ˆæ—¶å°±æ˜¯ å·¦-ä¸­-å³
            if(node.right != null){
                stack.push(node.right);
                map.put(node.right,1);
            } 
            stack.push(node);
            map.put(node,2);
            if(node.left != null){
                stack.push(node.left);
                map.put(node.left,1);
            }
                
            //å‰åºéå†
            if(node.right != null){
                stack.push(node.right);
                map.put(node.right,1);
            } 
            if(node.left != null){
                stack.push(node.left);
                map.put(node.left,1);
            }
            stack.push(node);
            map.put(node,2);
          
            //ååºéå†
            stack.push(node);
            map.put(node,2);
						if(node.right != null){
                stack.push(node.right);
                map.put(node.right,1);
            } 
            if(node.left != null){
                stack.push(node.left);
                map.put(node.left,1);
            } 
        }else{
            res.add(node.val);
        }
    }
    return res;
}
```



#### å±‚åºéå†

+ å±‚åºéå†ä¹Ÿå°±æ˜¯æˆ‘ä»¬ç»å¸¸æ‰€è¯´çš„å¹¿åº¦ä¼˜å…ˆéå† (BFS)

[LeetCodeâ€”â€”102ã€äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

[LeetCodeâ€”â€”107ã€äºŒå‰æ ‘çš„å±‚åºéå† 2](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```java
public class Tree_102_107 {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> lists = new ArrayList<>();
        if(root == null)
            return lists ;
        //æ ¸å¿ƒæ•°æ®ç»“æ„ : é˜Ÿåˆ—
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        //while å¾ªç¯æ¯ä¸€å±‚
        while(!q.isEmpty()){
            int sz = q.size();
            List<Integer> list = new ArrayList<>();
          	//for å¾ªç¯å¯¹å½“å‰å±‚è¿›è¡Œæ“ä½œ,åŒæ—¶å°†ä¸‹ä¸€å±‚å…¥é˜Ÿ
            for(int i = 0 ; i < sz ; ++i){
              	//å‡ºé˜Ÿæ“ä½œåœ¨for å¾ªç¯å†…,å®¹æ˜“å†™åˆ°å¤–é¢å¯¼è‡´å‡ºé”™
                TreeNode node = q.poll();
                list.add(node.val);
                if(node.left != null)
                    q.offer(node.left);
                if(node.right != null)
                    q.offer(node.right);
            }
            lists.add(list);
            //leetcode_107
            //lists.add(0,list); //lists.add(0,list) å¤´æ’ ğŸŒŸ
        }
        return lists;
    }
}
```



--------------

### åˆ¤æ–­ BST

+ å­¦ä¼šå››ç§éå†æ–¹å¼å, å…ˆè®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•é€šè¿‡ä¸­åºéå†çš„æ–¹å¼åˆ¤æ–­ä¸€ä¸ªæ ‘æ˜¯å¦ä¸ºä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘
+ æœ‰æ•ˆçš„äºŒå‰æ ‘å³ä¸­åºéå†ä¸ºå‡åº, è¿™é‡Œæˆ‘ä»¬åˆ©ç”¨æ ˆçš„ç‰¹æ€§è¿›è¡Œåˆ¤æ–­, ä»è€Œçœå»æ„å»ºå¥½ååœ¨åˆ¤æ–­çš„æ—¶é—´.

[LeetCodeâ€”â€”98ã€éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
public class IsValidBST_98 {
    public boolean isValidBST(TreeNode root) {
        double inorder = -Double.MAX_VALUE;
        Stack<TreeNode> stack = new Stack<>();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            // å¦‚æœä¸­åºéå†å¾—åˆ°çš„èŠ‚ç‚¹çš„å€¼å°äºç­‰äºå‰ä¸€ä¸ª inorderï¼Œè¯´æ˜ä¸æ˜¯äºŒå‰æœç´¢æ ‘
            if (root.val <= inorder)
                return false;
            inorder = root.val;
            root = root.right;
        }
        return true;
    }
}

```



--------

### æ„å»º BST

+ ç°åœ¨æˆ‘ä»¬èƒ½åˆ¤æ–­ BSTäº†, ä½†æ˜¯å¦‚ä½•æ„å»ºä¸€æ£µ BST å‘¢? å¦‚ä½•æ„å»ºå¤šæ£µä¸ä¸€æ ·çš„ BST å‘¢?

**é¢˜ç›®:  ç»™å®š n , æ„å»ºä¸€æ£µä» 1...n çš„æ ‘**

+ æ ¹æ® BST çš„ç‰¹æ€§, æˆ‘ä»¬å¾ˆå®¹æ˜“ç”¨çš„é€’å½’å†™å‡ºä»£ç .
+ å‡è®¾ç»™çš„æ˜¯ä¸€ä¸ªæ•°ç»„ nums[] , æˆ‘ä»¬åªéœ€è¦æŠŠæ–°å»ºèŠ‚ç‚¹å¤„æ”¹ä¸ºnums[i].å‚è§ [å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```java
public class BinaryTree {
    public TreeNode createBinaryTree(int n){
        return helper(1,n);
    }
    //æ„å»ºä¸€é¢—å¹³è¡¡äºŒå‰æ ‘
    public TreeNode helper(int start, int end){
        if(start > end){
            return null;
        }
        int i = (start + end) / 2;
        TreeNode root = new TreeNode(i);
        root.left = helper(start, i -1);
        root.right = helper(i + 1, end);
        return root;
    }
}
```



+ **è¿›é˜¶([leetcode--95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)):**

  ç»™å®šä¸€ä¸ªæ•´æ•° *n*ï¼Œç”Ÿæˆæ‰€æœ‰ç”± 1 ... *n* ä¸ºèŠ‚ç‚¹æ‰€ç»„æˆçš„**BST**.

  **éš¾åº¦:**ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ

  **è¯¯åŒº:**[listé›†åˆä¸ºç©ºæˆ–ä¸ºnullçš„åŒºåˆ«](https://blog.csdn.net/changqing5818/article/details/52373569?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.baidujs&dist_request_id=1328603.71811.16152838430118389&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.baidujs)

```java
public class GenerateTrees_95 {
    public List<TreeNode> generateTrees(int n){
        if(n == 0)
            return new LinkedList<TreeNode>();
        return generateTrees(1,n);
    }
    public List<TreeNode> generateTrees(int start, int end){
        List<TreeNode> allTrees = new LinkedList<>();
        //ç»“æŸæ¡ä»¶
        if(start > end){
          	//å¿…é¡»æ·»åŠ ä¸€ä¸ªç©ºå…ƒç´ ,ä¸ç„¶ä¸‹é¢æšä¸¾ä¼šå‡ºé”™
          	//æ¯”å¦‚ leftTrees = null , åˆ™ä¸ä¼šè¿›ç¬¬ä¸€å±‚forå¾ªç¯,å¯¼è‡´è¦èµ°çš„äºŒå±‚forå¾ªç¯æ— æ³•è¿›è¡Œ
          	//ä½†æ˜¯æ·»åŠ äº†ä¸€ä¸ªç©ºå…ƒç´ å, leftTree = [null], æ˜¯å«æœ‰ä¸€ä¸ªç©ºå…ƒç´ çš„,äºŒè€…çš„æ„æ€ä¸åŒ
            allTrees.add(null);
            return allTrees;
        }
        //æšä¸¾å¯è¡Œæ ¹èŠ‚ç‚¹
        for(int i = start ; i <= end ; i++){
            //è·å–æ‰€æœ‰å¯è¡Œçš„å·¦å­æ ‘é›†åˆ
            List<TreeNode> leftTrees = generateTrees(start, i - 1);
            List<TreeNode> rightTrees = generateTrees(i+1,end);

            //ä»å·¦å­æ ‘é›†åˆä¸­é€‰å‡ºä¸€ä¸ªå·¦å­æ ‘ï¼Œä»å³å­æ ‘é›†åˆä¸­é€‰å‡ºä¸€é¢—å³å­æ ‘ï¼Œæ‹¼æ¥åˆ°æ ¹èŠ‚ç‚¹ä¸Š
            for(TreeNode left : leftTrees){
                for(TreeNode right : rightTrees){
                    TreeNode currTree = new TreeNode(i);
                    currTree.left = left;
                    currTree.right = right;
                    allTrees.add(currTree);
                }
            }
        }
        return allTrees;
    }
}
```



--------------



### è¿˜åŸæ ‘(LeetCodeâ€”â€”105,106)

+ åˆ©ç”¨å‰åºéå†å’Œä¸­åºéå†è¿˜åŸæ ‘
+ **é‡è¦ç¨‹åº¦:**ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ
+ **è§£é¢˜å…³é”®:** ç¡®å®šæ¯æ¬¡å·¦å³å­æ ‘é€’å½’çš„ç•Œé™, é€šè¿‡HashMapå­˜å‚¨ä¸­åºéå†çš„å€¼å’Œä¸‹æ ‡, å®ç°$O(1)$çš„æŸ¥æ‰¾å¤æ‚åº¦, å¹¶ä»¥æ­¤è®¡ç®—å¾—åˆ°å·¦å³å­æ ‘çš„é•¿åº¦, ä»è€Œå¾—åˆ°ä¸‹æ ‡.
+ ä¸­åºéå†å’Œååºéå†è¿˜åŸæ ‘, åªéœ€è¦æ”¹å˜ä¸€ä¸‹ç»“æŸæ¡ä»¶å’Œé€’å½’çš„ä¸‹æ ‡å€¼å°±è¡Œ. 

![image-20210308151926067](æ ‘.assets/image-20210308151926067.png)

```java
import java.util.HashMap;
import java.util.Map;

public class Tree_105 {

    private Map<Integer, Integer> indexMap;

    public TreeNode buildTree(int[] preorder, int[] inorder){
        int n = preorder.length;
        indexMap = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < n ; i++){
            indexMap.put(inorder[i],i);
        }
        return myBuildTree(preorder, inorder, 0,n-1,0,n-1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right){
        //å‰åºå’Œä¸­åºéå†è¿˜åŸæ ‘çš„ç»“æŸæ¡ä»¶
      	if(preorder_left > preorder_right){
            return null;
        }

        //å‰åºéå†ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
        int preorder_root = preorder_left;
        //ä¸­åºéå†ä¸­å®šä½æ ¹èŠ‚ç‚¹
        int inorder_root = indexMap.get(preorder[preorder_root]);

        //å…ˆæŠŠæ ¹èŠ‚ç‚¹å»ºç«‹å‡ºæ¥
        TreeNode root = new TreeNode(preorder[preorder_root]);
        //å¾—åˆ°å·¦å­æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ç›®
        int size_left_subtree = inorder_root - inorder_left;

        //é€’å½’åœ°æ„é€ å·¦å­æ ‘ï¼Œ å¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
        root.left = myBuildTree(preorder, inorder , preorder_left + 1 , preorder_left + size_left_subtree , inorder_left , inorder_root - 1);
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);

        return root;
    }
}
```



-------------

### å¹³è¡¡äºŒå‰æ ‘

+ åˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘
+ **éš¾åº¦:**è‡ªåº•å‘ä¸Šæ€æƒ³â€”â€”ğŸŒŸğŸŒŸğŸŒŸ
+ å¹³è¡¡äºŒå‰æ ‘å®šä¹‰: ä¸€ä¸ªäºŒå‰æ ‘*æ¯ä¸ªèŠ‚ç‚¹* çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 
+ å½“é‡åˆ°é‡å¤è®¡ç®—é—®é¢˜æ—¶, å¯ä»¥è€ƒè™‘åæ–¹å‘æ€è€ƒ, ä¸€èˆ¬è‡ªåº•å‘ä¸Šä¼˜äºè‡ªé¡¶å‘ä¸‹

```java
//è‡ªé¡¶å‘ä¸‹ï¼ŒåŒé‡é€’å½’ï¼Œé‡å¤è®¡ç®—ï¼Œæ—¶é—´å¤æ‚åº¦é«˜
public boolean isBalanced(TreeNode root) {
    if(root == null)
        return true;
    else
        return Math.abs(getLength(root.left)-getLength(root.right))<=1
        && isBalanced(root.left) && isBalanced(root.right);
}
public int getLength(TreeNode root){
    if(root == null)
        return 0;
    return Math.max(getLength(root.left),getLength(root.right)) + 1;
}
```

```java
//è‡ªåº•å‘ä¸Š,ç±»ä¼¼ååºéå†
public boolean isBalanced2(TreeNode root){
    return height(root) >= 0;
}
public int height(TreeNode root){
    if(root == null){
        return 0;
    }
    int leftHeight ;
    int rightHeight ;
  	//å°†é€’å½’æ”¾å…¥åˆ¤æ–­é€»è¾‘ä¸­, è¾¾åˆ°å‰ªæçš„æ•ˆæœ, å¦‚æœå·¦å­æ ‘ä¸å¹³è¡¡åˆ™ä¸ç”¨é€’å½’å³å­æ ‘
    if((leftHeight = height(root.left)) == -1 || (rightHeight = height(root.right)) == -1 
       || Math.abs(leftHeight - rightHeight) > 1)
        return -1;
    else
        return Math.max(leftHeight,rightHeight) + 1;
}
```



-----

### äºŒå‰æ ‘çš„è·¯å¾„é—®é¢˜

+ æ¥ä¸‹æ¥è®©æˆ‘ä»¬æ¥çœ‹çœ‹äºŒå‰æ ‘çš„è·¯å¾„é—®é¢˜



[LeetCodeâ€”â€”112ã€è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)

[LeetCodeâ€”â€”129ã€æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

+ 112åˆ¤æ–­æ˜¯å¦å­˜åœ¨è·¯å¾„

+ 129æ‰€æœ‰è·¯å¾„å’Œç›¸åŠ 
+ **äºŒå‰æ ‘çš„è·¯å¾„æ•°å³å¶å­èŠ‚ç‚¹æ•°**, å¯ä»¥é‡‡ç”¨ BFS å’Œ DFS ä¸¤ç§æ–¹æ³•æ±‚è§£, ä¸ªäººæ¨è BFS 
+ ä½¿ç”¨ BFS æˆ‘ä»¬åªéœ€ä¸€ä¸ªé˜Ÿåˆ—å±‚åºéå†ä»ä¸Šåˆ°ä¸‹æ›´æ–°è·¯å¾„å’Œ, åˆ°å¶å­èŠ‚ç‚¹å‡ºè¿›è¡Œå¤„ç†å³å¯
+ ä¸¤é¢˜ä½¿ç”¨å±‚åºéå†çš„è§£æ³•æ ¸å¿ƒå¯ä»¥è¯´å‡ ä¹ç›¸åŒ, åªéœ€ä¿®æ”¹ä¸€ä¸‹å¤„ç†é€»è¾‘å³å¯



```java
//112ã€è·¯å¾„æ€»å’Œ, BFS
public boolean hasPathSum(TreeNode root, int sum) {
    if(root == null){
        return false;
    }
    //ä¸€ä¸ªé˜Ÿåˆ—å­˜å‚¨èŠ‚ç‚¹
    Queue<TreeNode> queNode = new LinkedList<>();
    //ä¸€ä¸ªé˜Ÿåˆ—å­˜å‚¨å€¼ï¼Œæ›´æ–°åˆ°æœ€ååªå‰©ä¸‹æ¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„å¯¹åº”çš„è·¯å¾„æ€»å’Œ
    Queue<Integer> queVal = new LinkedList<>();
    queNode.offer(root);
    queVal.offer(root.val);
    while(!queNode.isEmpty()){
        TreeNode now = queNode.poll();
        int temp = queVal.poll();
        //å¶èŠ‚ç‚¹å¤„è¿›è¡Œåˆ¤æ–­
        if(now.left == null && now.right == null){
            if(temp == sum){
                return true;
            }
            continue;
        }
        //
        if(now.left != null){
            queNode.offer(now.left);
            queVal.offer(now.left.val + temp);
        }
        if(now.right != null){
            queNode.offer(now.right);
            queVal.offer(now.right.val + temp);
        }
    }
    return false;
}

//129ã€æ‰€æœ‰è·¯å¾„å’Œã€BFS
public static int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<Integer> sum = new LinkedList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    sum.offer(root.val);
    int sumAll = 0;
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        int num = sum.poll();
        if (node.left == null && node.right == null) {
            sumAll += num;
        } else {
            if (node.left != null) {
                queue.offer(node.left);
                sum.offer(num * 10 + node.left.val);
            }
            if (node.right != null) {
                queue.offer(node.right);
                sum.offer(num * 10 + node.right.val);
            }
        }
    }
    return sumAll;
}
```



[LeetCodeâ€”â€”113ã€è·¯å¾„æ€»å’Œ 2](https://leetcode-cn.com/problems/path-sum-ii/)

+ 112çš„è¿›é˜¶, ç»™å‡ºæ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„è·¯å¾„
+ **å‚è€ƒ :** [å›æº¯æ³•è§£é¢˜æ¡†æ¶](https://labuladong.gitbook.io/algo/bi-du-wen-zhang/hui-su-suan-fa-xiang-jie-xiu-ding-ban)

```java
public class Tree_113 {
    List<List<Integer>> ret = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        dfs(root, sum);
        return ret;
    }
    public void dfs(TreeNode root, int sum){
        if(root == null){
            return ;
        }
        path.offerLast(root.val);
        sum -= root.val;
        if(root.left == null && root.right == null && sum == 0)
            ret.add(new LinkedList<Integer>(path));
        dfs(root.left, sum);
        dfs(root.right, sum);
        path.pollLast();
    }
}
```



-------

### å…¶ä»–

[LeetCodeâ€”â€”117ã€å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ 2](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

+ æœ¬é¢˜ä¸ 116 é¢˜ç›¸åŒ, åªæ˜¯è¦æ±‚ç©ºé—´åªèƒ½ä½¿ç”¨å¸¸æ•°çº§



```java
//æ ‘èŠ‚ç‚¹å®šä¹‰
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

//åˆ©ç”¨å±‚åºéå†, é€šè¿‡å·§å¦™åˆ©ç”¨å“‘èŠ‚ç‚¹, æŠŠæ¯ä¸€å±‚è¿æ¥æˆä¸€ä¸ªé“¾è¡¨
public Node connect(Node root) {
    if(root == null)
        return root;
    Node cur = root;
    while(cur != null){
        Node dummy = new Node(0);
        Node pre = dummy;
        while(cur != null){
            if(cur.left != null){
                pre.next = cur.left;
                pre = pre.next;
            }
            if(cur.right != null){
                pre.next = cur.right;
                pre = pre.next;
            }
            cur = cur.next;
        }
        cur = dummy.next;
    }
    return root;
}
```



[LeetCodeâ€”â€”173ã€äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

+ è‡ªå®šä¹‰äº†æ ‘è¿­ä»£å™¨ iterator çš„å†™æ³•

```java
class BSTIterator {
    ArrayList<Integer> list;
    int index = -1;
    public BSTIterator(TreeNode root) {
        list = new ArrayList<>();
        dfs(root);
    }
    public void dfs(TreeNode root){
        if(root != null){
            dfs(root.left);
            list.add(root.val);
            dfs(root.right);
        }
    }
    public int next() {
        index += 1;
        return list.get(index);
    }
    public boolean hasNext() {
        return index + 1 < list.size();
    }
}
```





ä»¥ä¸Šå°±æ˜¯ leetcode å‰ä¸¤ç™¾é“é¢˜æ ‘æ ‡ç­¾çš„é¢˜ç›®æ±‡æ€», å¯ä»¥çœ‹å‡º, åŸºæœ¬éƒ½é€ƒä¸å‡ºå››ç§éå†çš„æ¡†æ¶, æ‰€ä»¥é‡ç‚¹è®°å¿†å››ç§éå†æ¡†æ¶, å¤šåŠ ç»ƒä¹ ,  æ ‘ä½ å°±æŒæ¡å•¦!!